\input{preamble.tex}

\begin{document}
    \Header

    \BeginConspect

    \Section{? TODO: проблемы и доказательства}{}{Гагин Артур}
    
    \Subsection{Машины Тьюринга и тезис Чёрча}
   
    \begin{Def}[Машина Тьюринга]
        Да что за <<Машина Тьюринга>>?
        \begin{itemize}
            \item Абстрактная вычислительная машина.
            \item Формализация понятия алгоритма.
            \item Расширение конечного автомата.
            \item Лента (бесконечная).
            \item Головка записи-чтения (управляющее устройство), способная находиться в одном из множества состояний, которое конечно и точно задано.
            \item Это управляющее может перемещаться влево и вправо по ленте, читать и записывать в ячейки символы некоторого конечного алфавита.
            \item Существует $\epsilon$-символ, который заполняет все пустые клетки ленты.
            \item Управляющее устройство работает согласно правилам перехода, которые представляют алгоритм, реализуемый данной МТ. Каждое правило перехода предписывает машине, в зависимости от текущего состояния и наблюдаемого в текущей ячейке символа, записать в эту клетку новый символ, перейти в новое состояние и переместиться на одну клетку влево или вправо (существует некий <<синтаксический сахар>> --- остаться на месте). Некоторые состояния могут быть помечены как терминальные, и переход в любое из них означает конец работы, остановку алгоритма.
        \end{itemize}
        Это все очень интересно, но как насчет формализма?\\
        Формально: $M = \{Q, G, \epsilon, \Sigma, \delta, q_0, F\}$ --- запомните этот набор из семи элементов!
        \begin{itemize}
        \item $Q$ --- конечное, не являющееся пустым, множество состояний.
        \item $G$ --- конечный, не являющийся пустым, набор символов ленточного алфавита.
        \item $\epsilon$ --- единственный пустой символ.
        \item $\Sigma = G \backslash \{\epsilon\}$ --- набор входных символов.
        \item $\delta : (Q \backslash F) \times G \bcancel{\rightarrow}
        Q \times G \times \{L, R\}$ --- частичная функция, называемая функцией перехода, где $L$ --- сдвиг влево, а $R$ --- сдвиг вправо. Если $\delta$ не определена для текущего состояния и символа ленты, то машина останавливается.
        \item $q_0$ --- это начальное состояние.
        \item $F \subset {Q}$  --- набор конечных состояний.
        \end{itemize}
    \end{Def} 
    \begin{Rem}
        А что если мы хотим такое состояние, которое будет являться term при одном символе на ленте и nonterm при другом символе?\\
        Если немного подумать, то здесь все в порядке, поскольку мы можем сделать это состояние nonterm, перейти в другое term состояние, а при определенном символе сдвинуться, например, вправо, записав на ленту такой же символ, что был на ней.
    \end{Rem}
    \begin{Rem}
        Хоть любой конечный алфавит и не ограничен одними цифрами 0 и 1, очевидно, что мы всегда можем его представить в виде двоичных чисел, введя на нем порядок.
    \end{Rem}
    \begin{Def}[Частичная функция]
        частичная функция $f$ из множества $X$ в множество Y --- это функция из подмножества $S$ из $X$ (возможно, самого $X$) в $Y$ (обозначение: $\bcancel{\rightarrow}$). 
    \end{Def}
    \begin{Def}[Детерминированная и недетерминированная машины Тьюринга]
        Машина Тьюринга называется детерминированнй, если каждой паре состояни и ленточного символа соответствует не более одного правила. В ином случае, машина является недетерминированной.
    \end{Def}
    \begin{Def}[Тезис Черча/Тьюринга/Черча-Тьюринга]
        Есть ли отличие?\\
        На самом деле, все они говорят об одном, просто Черч в свое время придумал $\lambda$-исчисления, Тьюринг придумал Машину Тьюринга, а позже было показано, что эти формализмы эквивалентны.\\
        Сам тезис сформулируем следующим образом: Класс алгоритмически вычислимых частичных функций совпадает с классом всех функций, вычислимых на машине Тьюринга.
    \end{Def}
    \begin{Rem}
        Стоит понимать, что это именно тезис, а не теорема, ведь понятие <<алгоритмически вычислимая частичная функция>> неформально.
    \end{Rem}
    \begin{Def}[Вычислимая функция] Вычислимые функции — это множество функций         вида, $ f \colon N\ \to N $, которые могут быть реализованы на машине          Тьюринга.\\
        В качестве множества $N$ обычно рассматривается множество $B^{*}$ — множество слов в двоичном алфавите $B = \{0,1\}$, с оговоркой, что результатом вычисления может быть не только слово, но и специальное значение «неопределённость», соответствующее случаю, когда алгоритм «зависает». Таким образом, можно дать следующее определение $N$:\\
        $N=B^{*}\cup \{\operatorname{undef} \}$, где $B=\{0,1\}$, а $\operatorname{undef}$ — специальный элемент, означающий неопределённость.\\
        Роль множества $N$ может играть множество натуральных чисел, к которому добавлен элемент $ \operatorname{undef} $, и тогда вычислимые функции --- это некоторое подмножество натуральнозначных функций натурального аргумента. Удобно считать, что в качестве $N$ могут выступать различные счётные множества --- множество натуральных чисел, множество рациональных чисел, множество слов в каком-либо конечном алфавите и др. 
    \end{Def}
    \Subsection{Классы $RE$, $R$ и $co-RE$, доказательство $R = RE \cap co-RE$}
    \begin{Def}[Классы $RE$ и $co-RE$]
        Класс $RE$ (recursively enumerable) --- класс decision problems (проблемы принятия решения), для которых ответ <<да>> может быть проверен машиной Тьюринга за конечное время.
        \begin{itemize}
            \item Если на проблему ответ <<да>>, то существует некоторая процедура, которая требует конечного времени для определения этого.
            \item Ложь здесь отсутствует.
            \item Если на проблему ответ <<нет>>, то машина Тьюринга может остановиться, а может и не остановиться.
        \end{itemize}
        Класс $co-RE$ является дополнением к классу $RE$: ответ <<нет>> можно получить за конечное время абсолютно всегда, получение противоположного ответа может занять вечность.
    \end{Def}
    \begin{Def}[Формальный язык]
        Формальный язык (или просто язык) --- это множество конечных слов над конечным алфавитом.
    \end{Def}
    \begin{Def}[Класс $R$]
        $R$ --- класс decision problems, решаемых на МТ (набор всех рекурсивных языков). 
    \end{Def}
    \begin{Def}[Рекурсивный язык] Формальный язык является рекурсивным, если            существует полная машина Тьюринга (машина Тьюринга, которая останавливается для    каждого заданного ввода), которая, когда на вход подается конечная                  последовательность символов, принимает ее, если она принадлежит языку, и отвергает    ее в противном случае. 
    \end{Def}
    \begin{Thm}
        $R = RE \cap co-RE$.
    \end{Thm}
    \begin{proof}
        Обозначим за $X$ класс decision problems, содержащихся в классе $RE$, ответы <<да>> и <<нет>> на которые можно получить за конечное время. Очевидно, что $X \subset co-RE$ по определению, а также никакая другая задача, содержащаяся в $RE$ не содержится в $co-RE$. То есть, $X = RE \cap co-RE$. Однако $X = R$, так как это в точности класс decision problems, решаемых на машине Тьюринга, то есть: $R = X = RE \cap co-Re$.
    \end{proof}
    \Subsection{Проблемы Acceptence, Halting, Emptiness}
    \begin{Def}[Halting Problem]
        Проблема останова машины Тьюринга...
    \end{Def}

    \Section{? TODO: полностью}{}{Гагин Артур}

    \Section{?}{}{Гагин Артур}
        
    \Subsection{Построение универсальной машины Тьюринга}
    \begin{Def}[Универсальная машиина Тьюринга] Универсальная машина Тьюринга ---        такая машина, которая может заменить собой любую машину Тьюринга. Получив на     вход программу и входные данные, она вычисляет ответ, который вычислила бы по      входным данным машина Тьюринга, чья программа была дана на вход.
    \end{Def}
    \begin{Def}[Построение УМТ] 
    \end{Def}

    \Section{4?}{}{Гагин Артур}

    \Section{5?}{}{Гагин Артур}
    \Subsection{Определение классов сложности $P$, $NP$, $co-NP$}
    \begin{Def}[Класс сложности $P$] Классом $P$ называются все проблемы принятия решений,  которые могут быть решены детерминированной машиной Тьюринга с использованием         полиномиального количества времени вычислений или полиномиального времени.
    \end{Def}
    \begin{Example}[Задача из класса сложности $P$]
        Пусть у нас есть массив натуральных чисел, состоящий из $n$ элементов. Вопрос: содержится ли число 5 в этом массиве?\\
        Решение: Простой перебор элементов массива (если массив упорядочен, то можно воспользоваться бинарным поиском).
    \end{Example}
    \begin{Def}[Класс сложности $NP$]
        Классом $NP$ называют множество задач принятия решения, решение с ответом <<да>> каждой из которых можно проверить на детерминированной машине Тьюринга за время, не превосходящее какой-либо полином.
    \end{Def}
    \begin{Example}[Задача из класса сложности $NP$] 
        Дано число $n$. Вопрос: раскладывается ли данное число на три простых?\\
        Решение: заметим, что нельзя точно утверждать, содержится ли данная задача в классе $P$, поскольку единственное решение, которое пока что придумано --- это простой перебор, занимающий более чем полиномиальное время работы. Однако если у нас на руках существует решение данной задачи с ответом <<да>>, то мы легко можем проверить данное решение, перемножив три числа, содержащихся в решении. Если перемножение дает верный ответ, то решение верно, и наоборот. Доказательство того, что проверка занимает не более чем экспоненциальное время оставим в качестве упражнения читателям.
    \end{Example}
    \begin{Rem}
        На самом деле, решение прошлой задачи с ответом <<нет>> тоже можно проверить за экспоненциальное время. Само решение будет состоять в том, чтобы показать, что число раскладывается не на три простых, а на какое-либо другое количество. Проверка решения аналогична: перемножить и убедиться, либо же опровергнуть корректность решения. Это значит, что описанная нами задача также принадлежит и классу $co-NP$, о котором сказано ниже.
    \end{Rem}
    \begin{Rem}
        Очевидно: $P \subset NP$ (если мы можем решить задачу за полиномиальное время, то мы можем проверить решение задачи, просто решив ее).
    \end{Rem}
    \begin{Def}[Класс сложности $co-NP$]
        Классом $co$-$NP$ называют множество задач принятия решения, дополнение к которому лежит в классе $NP$. Это означает, что каждая задача, решение которой с ответом <<нет>> можно проверить на детерминированной машине Тьюринга за время, не превосходящее какой-либо полином, лежит в классе $co$-$NP$.
    \end{Def}
    \Subsection{Определение полиномиальной сводимости и класса $NP$-полных языков}
    \begin{Def}[Полиномиальная сводимость]
    Любой язык $L_1$ называется сводимым по Карпу к языку $L_2$, если существует функция $F\colon \Sigma ^{*}\mapsto \Sigma ^{*}$, вычисляемая за полиномиальное время, где F(x) принадлежит $L_2$ в том случае, если x принадлежит $L_1$. 
    \end{Def}
    \begin{Def}[Класс сложности $NP$-$complete$]
     Класс $NP$-$complete$ --- множество задач принятия решения из класса $NP$, к каждой из которых можно свести \textbf{любую} другую задачу из этого класса за полиномиальное время.
    \end{Def}
    \begin{Rem}
    Найдя алгоритм для решения любой задачи из класса $NP$-$complete$ за полиномиальное время, возможно решать каждую задачу $NP$ за полиномиальное время, а это решает проблему $P=NP$.
    \end{Rem}
    \Subsection{Взаимосвязи этих классов}
    \begin{Rem}
        Взаимосвязи:\\
        $P \subset NP$;\\
        $P \subset co-NP$;\\
        $NP \cap co-NP \neq \emptyset$.
    \end{Rem}
    \Subsection{Доказательство того, что если $NP$-полный язык лежит в $co-NP$, то $NP = co-NP$}
    \begin{Thm}
    Если $NP$-полный язык лежит в $co$-$NP$, то $NP = co$-$NP$.
    \end{Thm}
    \begin{proof}
    Пусть $L$ --- это язык из класса $co-NP$. Заметим, что дополнение к этому языку лежит в классе $NP$. Сведем это дополнение к $NP$-полному языку (за полиномиальное время), который лежит в $co-NP$. Получается, что дополнение к языку $L$ лежит в классе $co-NP$. Данное рассуждение мы можем проделать для любого $co-NP$ языка. Получается, что дополнения к каждой задаче лежат в $co-NP$, но эти дополнения по определению лежат в $NP$, а значит $NP = co-NP$.
    \end{proof}


    \Section{x}{}{Гагин Артур}

    \Section{x}{}{Гагин Артур}
    \Subsection{Теорема Кука-Левина об NP-полноте задачи CNF-SAT}
    \begin{Def}[Булева формула]
        Булева формула --- формула логики высказываний.
    \end{Def}
    \begin{Rem}
        Формула называется тождественно истинной (ложной), если она истинна (ложна) при любых значениях переменных. Две булевы формулы называются эквивалентными тогда и только тогда, когда они истинны на одном и том же подмножестве множества значений аргументов.
    \end{Rem}
    \begin{Def}[Задача SAT]
    Задача SAT --- это задача выполнимости булевых формул. Экземпляром задачи является булева формула, состоящая только из имён переменных, скобок и операций  $\wedge$ (И), $\vee$ (ИЛИ) и $\neg$ (HE). Задача заключается в следующем: можно ли назначить всем переменным, встречающимся в формуле, значения ложь и истина так, чтобы формула стала истинной.
    \end{Def}
    \begin{Def}[Задача CNF-SAT]
    Определение почти аналогично, однако на булеву формулу накладывается ограничение: она должна быть записана в конъюнктивной нормальной форме (должна иметь вид конъюнкции дизъюнкций литералов).
    \end{Def}
    \begin{Rem}
        Любая булева формула может быть приведена к КНФ.
    \end{Rem}
    \begin{Example}
        Формулы в КНФ:\\
        $\neg A\wedge (B\vee C)$;\\
        $(A\vee B)\wedge (\neg B\vee C\vee \neg D)\wedge (D\vee \neg E)$;\\
        $A\wedge B$.\\
        Формулы не в КНФ:\\
        $\neg (B\vee C)$;\\
        $(A\wedge B)\vee C$;\\
        $A\wedge (B\vee (D\wedge E))$.
    \end{Example}
    \begin{Def}[Задача 3-SAT]
    Задача 3-SAT --- частный случай задачи SAT, где булева формула записана в 3-конъюнктивной нормальной форме.
    \end{Def}
    \begin{Def}[k-КНФ]
    k-конъюнктивной нормальной формой называют конъюнктивную нормальную форму, в которой каждая дизъюнкция содержит ровно k литералов.
    \end{Def}
    \begin{Example}
    Следующая формула записана в 2-КНФ:
    $(A\lor B)\land (\neg B\lor C)\land (B\lor \neg C)$.
    \end{Example}
    \begin{Def}[Задача 1-in-3-SAT]
    Задача 1-in-3-SAT --- частный случай задачи 3-SAT, где каждая дизъюнкция содержит три литерала, только один из которых может быть правдив (TRUE).
    \end{Def}
    \begin{Thm}[Теорема Кука-Левина]
    Задача CNF-SAT выполнимости является NP-полной. То есть она находится в NP, и любая задача в NP может быть сведена за полиномиальное время детерминированной машиной Тьюринга к булевой задаче выполнимости.
    \end{Thm}


    \Subsection{co-NP-полнота задачи TAUTOLOGY}
    \begin{Def}[Тавтология]
    Тавтологией называется формула или утверждение, которое верно во всех возможных интерпретациях.
    \end{Def}
    \begin{Example}
        $x \neq y \lor x = y$.
    \end{Example}
    \begin{Def}[co-NP-complete]
    Язык $L$ называется co-NP-complete, если любой co-NP язык можно свести к этому языку за время, не превосходящее какой-либо полином.
    \end{Def}
\end{document}